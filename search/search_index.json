{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FLOWUnsteady Documentation","title":"Home"},{"location":"#flowunsteady-documentation","text":"","title":"FLOWUnsteady Documentation"},{"location":"how-to-guide/calculate-aerodynamic-forces/","text":"","title":"Calculate aerodynamic forces"},{"location":"how-to-guide/define-a-rotor/","text":"","title":"Define a rotor"},{"location":"how-to-guide/define-kinematic-maneuvers/","text":"","title":"Define kinematic maneuvers"},{"location":"how-to-guide/defining-systems/","text":"","title":"Defining systems"},{"location":"how-to-guide/getting-started/","text":"","title":"Getting started"},{"location":"how-to-guide/how-to/","text":"","title":"How to"},{"location":"how-to-guide/paraview-visualization/","text":"","title":"Paraview visualization"},{"location":"how-to-guide/select-a-solver/","text":"","title":"Select a solver"},{"location":"how-to-guide/set-up-monitors/","text":"","title":"Set up monitors"},{"location":"how-to-guide/set-up-runtime-functions/","text":"","title":"Set up runtime functions"},{"location":"reference/FLOWUnsteady/","text":"","title":"FLOWUnsteady"},{"location":"reference/FLOWVLM/","text":"FLOWVLM FLOWVLM is a vortex lattice method (VLM) code for solving aerodynamics, but is far more than that. FLOWVLM has a general three-dimensional geometric engine that powers much of the geometry of FLOWUnsteady and is also the foundation of the blade-element rotor solver. In this section we describe how wing geometries are defined, how multiple wings can be grouped into a wing system, and how objects can be rotated and translated in space. Wing Definition A FLOWVLM.Wing object is simply a data structure that encapsulates a collection of horseshoes vortices (or a vortex lattice). A horseshoe vortex is made out of one bound vortex located at the quarter-chord position, two trailing bound vortices going back to the trailing edge, and two semi-infinite vortices extending from the trailing edge out in the direction of the freestream, as shown below. A control point is associated to every horseshoe, which is located at the three-quarter chord position. At this point, the no-flow-through boundary condition is imposed, canceling the component of the freestream that is normal to the surface. !!! note \"Unsteady wake\" In the unsteady solver of FLOWUnsteady, semi-infinite trailing vortices of the horseshoes are replaced by vortex particles that are shed off the trailing edge at every time step. There are three ways of defining a VLM wing. The first one is to manually add chord stations along the wing and discretize the sections in between into horseshoes. This approach is tedious and is rarely used. The second one is through the function FLOWVLM.SimpleWing that takes the parameters of the root and tip of the wing and interpolates and discretizes everything in between, which works well for most conventional wings. Finally, for complex geometries (for instance, an asymmetric wing or a wing with winglets), the user can call FLOWVLM.ComplexWing that works pretty much like the option of manually building the wing but in a friendlier way. Manually Building the Wing You can build a wing by adding each chord station manually and indicating the discretization in between. This is done by indicating the leading edge position and chord length at each station, and the number of horseshoes in between stations. This approach uses the FLOWVLM.Wing constructor to initialize the wing and the FLOWVLM.addwing function to add each chord. # FLOWVLM.Wing \u2014 Type . Wing(leftxl, lefty, leftz, leftchord, leftchordtwist) Wing constructor that automatically discretizes the surface into lattices. The wing must we built from left to right. Chords are parallel to the zx-plane, leading edge in the direction of the -xaxis and trailing in the direction of the +xaxis (hence, the span is aligned with the y-axis). Arguments leftxl : x-position of leading edge of the left tip. lefty : y-position of left tip. `leftzl : z-position of leading edge of the left tip. leftchord : Chord of the left tip. leftchordtwist : Twist left tip's chord in degrees. Example julia julia> wing = Wing(0.0, 0.0, 0.0, 10.0, 3.0); source # FLOWVLM.addchord \u2014 Function . addchord(wing, x, y, z, c, twist, n, r=1.0) Adds a new chord to the wing and creates n lattices in the new section. Wing must be build from left to right. Arguments x : x-position leading edge of the chord. y : y-position of the chord. z : z-position leading edge of the chord. c : Chord length. twist : Twist of the chord in degrees. n::Int64: Number of lattices in the new section. Optional arguments r : Ratio between lengths of first and last lattices. central : Give it true to take the length ratio between the lattice midway and first and last. Give it a number between 0 and 1 to define the position of the reference midway. refinement : Use this option for more complex refinements. It receives an array `[sec1, sec2, ...]` with sections of refinements in the format `sec=[c, n, r]`, with `c` the length of this section (sum of all c = 1), `n` the ratio of lattices in this section, and `r` the increment ratio. If this option is used, it will ignore arguments `r` and `central`. Examples `julia> wing = Wing(0.0, 0.0, 0.0, 10.0, 3.0);` `julia> addchord(wing, 2.5, 10.0, 5.0, 5.0, 0.0, 10);` source This requires the user to do all the calculations of what the geometry should look like based on the desired aspect ratio, taper ratio, etc. In the following line we are doing such calculations for a $40^\\circ$-swept-back wing with an aspect ratio of 5.0. # Wing parameters b = 98*0.0254 # (m) span ar = 5.0 # Aspect ratio (span over tip chord) tr = 1.0 # Taper ratio lambda = 45.0 # (deg) sweep gamma = 0.0 # (deg) dihedral twist_tip = 0.0 # (deg) tip twist twist_root = 0.0 # (deg) root twist n = 4 # Horseshoes in between chord stations # Calculations cr = 1/tr # Chord ratio (inverse of taper ratio) c_tip = b/ar # Chord at tip c_root = cr*c_tip # Chord at root y_tip = b/2 # y-position of tip leading edge x_tip = y_tip*tan(lambda*pi/180)# x-position of tip leading edge z_tip = y_tip*tan(gamma*pi/180) # z-position of tip leading edge We initialize the wing by giving it the first chord station, which corresponds to the left chord. import FLOWVLM vlm = FLOWVLM # Initialize the wing with the left tip chord wing = vlm.Wing(x_tip, -y_tip, z_tip, c_tip, twist_tip) Then we go on to add the root and the right tip chord. # Add the root chord vlm.addchord(wing, 0.0, 0.0, 0.0, c_root, twist_root, n) # Add the right tip chord vlm.addchord(wing, x_tip, y_tip, z_tip, c_tip, twist_tip, n) Notice that we placed the root at the (0, 0, 0) position. This doesn't always have to be this way, but remember to move the other chord stations accordingly if you want to place the nose somewhere else. !!! Tip \"Build wings from left to right\" It is recommended that wings are build from left to right, or from $-y$ to $+y$. Otherwise, the normals of the surface will point down in the negative $z$-direction and the circulation of the wing will be negative when generating upwards lift (positive $z$-direction). This is not a problem for the solver, but could be difficult to wrap your head around a negative circulation being associated to a positive lift. SimpleWing asdasd ComplexWing","title":"FLOWVLM"},{"location":"reference/FLOWVLM/#flowvlm","text":"FLOWVLM is a vortex lattice method (VLM) code for solving aerodynamics, but is far more than that. FLOWVLM has a general three-dimensional geometric engine that powers much of the geometry of FLOWUnsteady and is also the foundation of the blade-element rotor solver. In this section we describe how wing geometries are defined, how multiple wings can be grouped into a wing system, and how objects can be rotated and translated in space.","title":"FLOWVLM"},{"location":"reference/FLOWVLM/#wing-definition","text":"A FLOWVLM.Wing object is simply a data structure that encapsulates a collection of horseshoes vortices (or a vortex lattice). A horseshoe vortex is made out of one bound vortex located at the quarter-chord position, two trailing bound vortices going back to the trailing edge, and two semi-infinite vortices extending from the trailing edge out in the direction of the freestream, as shown below. A control point is associated to every horseshoe, which is located at the three-quarter chord position. At this point, the no-flow-through boundary condition is imposed, canceling the component of the freestream that is normal to the surface. !!! note \"Unsteady wake\" In the unsteady solver of FLOWUnsteady, semi-infinite trailing vortices of the horseshoes are replaced by vortex particles that are shed off the trailing edge at every time step. There are three ways of defining a VLM wing. The first one is to manually add chord stations along the wing and discretize the sections in between into horseshoes. This approach is tedious and is rarely used. The second one is through the function FLOWVLM.SimpleWing that takes the parameters of the root and tip of the wing and interpolates and discretizes everything in between, which works well for most conventional wings. Finally, for complex geometries (for instance, an asymmetric wing or a wing with winglets), the user can call FLOWVLM.ComplexWing that works pretty much like the option of manually building the wing but in a friendlier way.","title":"Wing Definition"},{"location":"reference/FLOWVLM/#manually-building-the-wing","text":"You can build a wing by adding each chord station manually and indicating the discretization in between. This is done by indicating the leading edge position and chord length at each station, and the number of horseshoes in between stations. This approach uses the FLOWVLM.Wing constructor to initialize the wing and the FLOWVLM.addwing function to add each chord. # FLOWVLM.Wing \u2014 Type . Wing(leftxl, lefty, leftz, leftchord, leftchordtwist) Wing constructor that automatically discretizes the surface into lattices. The wing must we built from left to right. Chords are parallel to the zx-plane, leading edge in the direction of the -xaxis and trailing in the direction of the +xaxis (hence, the span is aligned with the y-axis). Arguments leftxl : x-position of leading edge of the left tip. lefty : y-position of left tip. `leftzl : z-position of leading edge of the left tip. leftchord : Chord of the left tip. leftchordtwist : Twist left tip's chord in degrees. Example julia julia> wing = Wing(0.0, 0.0, 0.0, 10.0, 3.0); source # FLOWVLM.addchord \u2014 Function . addchord(wing, x, y, z, c, twist, n, r=1.0) Adds a new chord to the wing and creates n lattices in the new section. Wing must be build from left to right. Arguments x : x-position leading edge of the chord. y : y-position of the chord. z : z-position leading edge of the chord. c : Chord length. twist : Twist of the chord in degrees. n::Int64: Number of lattices in the new section. Optional arguments r : Ratio between lengths of first and last lattices. central : Give it true to take the length ratio between the lattice midway and first and last. Give it a number between 0 and 1 to define the position of the reference midway. refinement : Use this option for more complex refinements. It receives an array `[sec1, sec2, ...]` with sections of refinements in the format `sec=[c, n, r]`, with `c` the length of this section (sum of all c = 1), `n` the ratio of lattices in this section, and `r` the increment ratio. If this option is used, it will ignore arguments `r` and `central`. Examples `julia> wing = Wing(0.0, 0.0, 0.0, 10.0, 3.0);` `julia> addchord(wing, 2.5, 10.0, 5.0, 5.0, 0.0, 10);` source This requires the user to do all the calculations of what the geometry should look like based on the desired aspect ratio, taper ratio, etc. In the following line we are doing such calculations for a $40^\\circ$-swept-back wing with an aspect ratio of 5.0. # Wing parameters b = 98*0.0254 # (m) span ar = 5.0 # Aspect ratio (span over tip chord) tr = 1.0 # Taper ratio lambda = 45.0 # (deg) sweep gamma = 0.0 # (deg) dihedral twist_tip = 0.0 # (deg) tip twist twist_root = 0.0 # (deg) root twist n = 4 # Horseshoes in between chord stations # Calculations cr = 1/tr # Chord ratio (inverse of taper ratio) c_tip = b/ar # Chord at tip c_root = cr*c_tip # Chord at root y_tip = b/2 # y-position of tip leading edge x_tip = y_tip*tan(lambda*pi/180)# x-position of tip leading edge z_tip = y_tip*tan(gamma*pi/180) # z-position of tip leading edge We initialize the wing by giving it the first chord station, which corresponds to the left chord. import FLOWVLM vlm = FLOWVLM # Initialize the wing with the left tip chord wing = vlm.Wing(x_tip, -y_tip, z_tip, c_tip, twist_tip) Then we go on to add the root and the right tip chord. # Add the root chord vlm.addchord(wing, 0.0, 0.0, 0.0, c_root, twist_root, n) # Add the right tip chord vlm.addchord(wing, x_tip, y_tip, z_tip, c_tip, twist_tip, n) Notice that we placed the root at the (0, 0, 0) position. This doesn't always have to be this way, but remember to move the other chord stations accordingly if you want to place the nose somewhere else. !!! Tip \"Build wings from left to right\" It is recommended that wings are build from left to right, or from $-y$ to $+y$. Otherwise, the normals of the surface will point down in the negative $z$-direction and the circulation of the wing will be negative when generating upwards lift (positive $z$-direction). This is not a problem for the solver, but could be difficult to wrap your head around a negative circulation being associated to a positive lift.","title":"Manually Building the Wing"},{"location":"reference/FLOWVLM/#simplewing","text":"asdasd","title":"SimpleWing"},{"location":"reference/FLOWVLM/#complexwing","text":"","title":"ComplexWing"},{"location":"reference/VPM/","text":"","title":"VPM"},{"location":"reference/theory/","text":"","title":"Theory"},{"location":"tutorials/first-steps/","text":"First Steps Geometry Basics In this tutorial, we'll begin by defining the geometry for a simple wing. Note that all the functions used are described in the Reference section of this documentation if you would like further information at any point. Before you begin this tutorial, it is expected that you've already installed the necessary components of FLOWUnsteady, and that you are familiar with visualization in Paraview. First things first, we need to include the FLOWUnsteady components import FLOWUnsteady uns = FLOWUnsteady vlm = uns.vlm Let's begin with a single section, symmetric wing. We'll start by defining some basic geometry. span = 1.0 aspectratio = 10.0 taperratio = 0.5 wingtwist = 0.0 wingsweep = 10.0 #degrees wingdihedral = 7.0 #degrees Then we'll call the tut() function to create a simple wing object. mainwing = vlm.simpleWing(span,aspectratio,taperratio,wingtwist,wingsweep,wingdihedral) FLOWVLM.Wing(0.08816349035423249, -0.5, 0.0613922804514523, 0.1, 0.0, 40, Real[0.0, 0.0, 0.0], Real[1.0 0 0; 0 1 0; 0 0 1], Real[1.0 0 0; 0 1 0; 0 0 1], nothing, Dict{String,Any}(), Real[0.0881635, 0.0852247, 0.0821313, 0.0788831, 0.0754803, 0.0719228, 0.0682107, 0.0643439, 0.0603224, 0.0561462 \u2026 0.0561462, 0.0603224, 0.0643439, 0.0682107, 0.0719228, 0.0754803, 0.0788831, 0.0821313, 0.0852247, 0.0881635], Real[0.188163, 0.188558, 0.188973, 0.189409, 0.189866, 0.190344, 0.190842, 0.191361, 0.191901, 0.192462 \u2026 0.192462, 0.191901, 0.191361, 0.190842, 0.190344, 0.189866, 0.189409, 0.188973, 0.188558, 0.188163], Real[-0.5, -0.483333, -0.465789, -0.447368, -0.42807, -0.407895, -0.386842, -0.364912, -0.342105, -0.318421 \u2026 0.318421, 0.342105, 0.364912, 0.386842, 0.407895, 0.42807, 0.447368, 0.465789, 0.483333, 0.5], Real[0.0613923, 0.0593459, 0.0571918, 0.0549299, 0.0525604, 0.0500832, 0.0474982, 0.0448056, 0.0420052, 0.0390972 \u2026 0.0390972, 0.0420052, 0.0448056, 0.0474982, 0.0500832, 0.0525604, 0.0549299, 0.0571918, 0.0593459, 0.0613923], Real[0.0613923, 0.0593459, 0.0571918, 0.0549299, 0.0525604, 0.0500832, 0.0474982, 0.0448056, 0.0420052, 0.0390972 \u2026 0.0390972, 0.0420052, 0.0448056, 0.0474982, 0.0500832, 0.0525604, 0.0549299, 0.0571918, 0.0593459, 0.0613923], Real[0.162944, 0.162494, 0.16202, 0.161524, 0.161004, 0.160462, 0.159896, 0.159307, 0.158695, 0.15806 \u2026 0.15806, 0.158695, 0.159307, 0.159896, 0.160462, 0.161004, 0.161524, 0.16202, 0.162494, 0.162944], Real[-0.491667, -0.474561, -0.456579, -0.437719, -0.417982, -0.397368, -0.375877, -0.353509, -0.330263, -0.30614 \u2026 0.30614, 0.330263, 0.353509, 0.375877, 0.397368, 0.417982, 0.437719, 0.456579, 0.474561, 0.491667], Real[0.0603691, 0.0582688, 0.0560608, 0.0537452, 0.0513218, 0.0487907, 0.0461519, 0.0434054, 0.0405512, 0.0375893 \u2026 0.0375893, 0.0405512, 0.0434054, 0.0461519, 0.0487907, 0.0513218, 0.0537452, 0.0560608, 0.0582688, 0.0603691], Real[0.113163, 0.111058, 0.108842, 0.106515, 0.104077, 0.101528, 0.0988686, 0.0960983, 0.0932171, 0.0902252 \u2026 0.0902252, 0.0932171, 0.0960983, 0.0988686, 0.101528, 0.104077, 0.106515, 0.108842, 0.111058, 0.113163], Real[-0.5, -0.483333, -0.465789, -0.447368, -0.42807, -0.407895, -0.386842, -0.364912, -0.342105, -0.318421 \u2026 0.318421, 0.342105, 0.364912, 0.386842, 0.407895, 0.42807, 0.447368, 0.465789, 0.483333, 0.5], Real[0.0613923, 0.0593459, 0.0571918, 0.0549299, 0.0525604, 0.0500832, 0.0474982, 0.0448056, 0.0420052, 0.0390972 \u2026 0.0390972, 0.0420052, 0.0448056, 0.0474982, 0.0500832, 0.0525604, 0.0549299, 0.0571918, 0.0593459, 0.0613923], nothing) Congratulations! You've created your first wing object. If you want, you can take a moment to explore the contents of your newly created mainwing . You can do so using fieldnames(mainwing) and poking around. The Reference section will have more info on the contents of the wing object. Next, let's create a wing system. system = vlm.WingSystem() FLOWVLM.WingSystem(Any[], String[], Real[0.0, 0.0, 0.0], Real[1.0 0 0; 0 1 0; 0 0 1], Real[1.0 0 0; 0 1 0; 0 0 1], nothing, Dict{String,Any}()) You now have an empty wing system, so let's add our mainwing object to it with the name \"mainwing.\" vlm.addwing(system,\"mainwing\",mainwing) Now that we have a wing system, let's save it as a .vtk file so we can view it in paraview. In order to do so, we are required to define a freestream velocity. Vinf(x,t) = [1,0,0] vlm.setVinf(system, Vinf) We will also want to set some parameters for saving files and set up our file system to put the files where we want. run_name = \"tutorial\" save_path = \"./simplewing/\" run(`rm -rf $save_path`) run(`mkdir $save_path`) Finally, we can save the files. vlm.save(system, run_name; path=save_path) And now we can view our wing in Paraview using the command run(`paraview --data=\"$(save_path)/$(run_name)_mainwing_vlm.vtk\"`) (assuming you've set up an alias for paraview on your computer). Adding a Rotor Now that we have a basic wing, let's go ahead and add a rotor. We'll use some data for the rotor that already exists in FLOWUnsteady. You can visit the How-to guides for more information on creating your own rotor database. rotor_file = \"apc10x7.csv\" # Rotor geometry data_path = uns.def_data_path # Path to rotor database With the rotor data, we can generate our rotor. This might take a minute or so to run. We supress the output here with a semi-colon as it prints a large output. rotor = uns.generate_rotor(rotor_file; pitch=0.0, n=10, CW=true, ReD=1.5e6, verbose=true, xfoil=false, data_path=data_path, plot_disc=false); Generating geometry... Generating airfoils... n4412-1500000.csv n4412-1500000.csv n4412-1500000.csv n4412-1500000.csv n4412-1500000.csv Generating FLOWVLM Rotor... And then we can generate a rotor object, where we again supress the output. rotors = vlm.Rotor[rotor]; This will put the rotor at the default location and orientation which we will define here since we now need to move the rotor relative to the wing which is already at this location. vehicleorigin = [0.0; 0.0; 0.0] vehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0] 3\u00d73 Array{Float64,2}: 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 To move the rotor, we need to define a new origin point. rotororigin = [-0.1; 0.0; 0.0] 3-element Array{Float64,1}: -0.1 0.0 0.0 Then we can use that origin to set the rotor coordinate system in order to move the rotor. for rotor in rotors vlm.setcoordsystem(rotor, rotororigin, vehicleaxis; user=true) end which we can put in a tuple that stores our rotor system(s). rotors_system = (rotor,); We also need to add it to our overall system. for rotor in rotors; vlm.addwing(system, run_name, rotor); end; Like setting the Vinf parameter for the main wing, we need to give our rotor an RPM as well. for rotor in rotors; vlm.setRPM(rotor, 6000); end; We should now be able to visualize our wing with a rotor. run(`rm -rf $save_path`) run(`mkdir $save_path`) vlm.save(system, run_name; path=save_path) run(`paraview --data=\"$(save_path)/tutorial_mainwing_vlm.vtk;tutorial_tutorial_Blade1_vlm.vtk;tutorial_tutorial_Blade2_vlm.vtk;tutorial_tutorial_Blade1_loft.vtk;tutorial_tutorial_Blade2_loft.vtk;\"`) Other Systems VLM Systems Wake Systems Tilting Systems Kinematic Maneuvers Setting up a Basic Simulation","title":"First steps"},{"location":"tutorials/first-steps/#first-steps","text":"","title":"First Steps"},{"location":"tutorials/first-steps/#geometry-basics","text":"In this tutorial, we'll begin by defining the geometry for a simple wing. Note that all the functions used are described in the Reference section of this documentation if you would like further information at any point. Before you begin this tutorial, it is expected that you've already installed the necessary components of FLOWUnsteady, and that you are familiar with visualization in Paraview. First things first, we need to include the FLOWUnsteady components import FLOWUnsteady uns = FLOWUnsteady vlm = uns.vlm Let's begin with a single section, symmetric wing. We'll start by defining some basic geometry. span = 1.0 aspectratio = 10.0 taperratio = 0.5 wingtwist = 0.0 wingsweep = 10.0 #degrees wingdihedral = 7.0 #degrees Then we'll call the tut() function to create a simple wing object. mainwing = vlm.simpleWing(span,aspectratio,taperratio,wingtwist,wingsweep,wingdihedral) FLOWVLM.Wing(0.08816349035423249, -0.5, 0.0613922804514523, 0.1, 0.0, 40, Real[0.0, 0.0, 0.0], Real[1.0 0 0; 0 1 0; 0 0 1], Real[1.0 0 0; 0 1 0; 0 0 1], nothing, Dict{String,Any}(), Real[0.0881635, 0.0852247, 0.0821313, 0.0788831, 0.0754803, 0.0719228, 0.0682107, 0.0643439, 0.0603224, 0.0561462 \u2026 0.0561462, 0.0603224, 0.0643439, 0.0682107, 0.0719228, 0.0754803, 0.0788831, 0.0821313, 0.0852247, 0.0881635], Real[0.188163, 0.188558, 0.188973, 0.189409, 0.189866, 0.190344, 0.190842, 0.191361, 0.191901, 0.192462 \u2026 0.192462, 0.191901, 0.191361, 0.190842, 0.190344, 0.189866, 0.189409, 0.188973, 0.188558, 0.188163], Real[-0.5, -0.483333, -0.465789, -0.447368, -0.42807, -0.407895, -0.386842, -0.364912, -0.342105, -0.318421 \u2026 0.318421, 0.342105, 0.364912, 0.386842, 0.407895, 0.42807, 0.447368, 0.465789, 0.483333, 0.5], Real[0.0613923, 0.0593459, 0.0571918, 0.0549299, 0.0525604, 0.0500832, 0.0474982, 0.0448056, 0.0420052, 0.0390972 \u2026 0.0390972, 0.0420052, 0.0448056, 0.0474982, 0.0500832, 0.0525604, 0.0549299, 0.0571918, 0.0593459, 0.0613923], Real[0.0613923, 0.0593459, 0.0571918, 0.0549299, 0.0525604, 0.0500832, 0.0474982, 0.0448056, 0.0420052, 0.0390972 \u2026 0.0390972, 0.0420052, 0.0448056, 0.0474982, 0.0500832, 0.0525604, 0.0549299, 0.0571918, 0.0593459, 0.0613923], Real[0.162944, 0.162494, 0.16202, 0.161524, 0.161004, 0.160462, 0.159896, 0.159307, 0.158695, 0.15806 \u2026 0.15806, 0.158695, 0.159307, 0.159896, 0.160462, 0.161004, 0.161524, 0.16202, 0.162494, 0.162944], Real[-0.491667, -0.474561, -0.456579, -0.437719, -0.417982, -0.397368, -0.375877, -0.353509, -0.330263, -0.30614 \u2026 0.30614, 0.330263, 0.353509, 0.375877, 0.397368, 0.417982, 0.437719, 0.456579, 0.474561, 0.491667], Real[0.0603691, 0.0582688, 0.0560608, 0.0537452, 0.0513218, 0.0487907, 0.0461519, 0.0434054, 0.0405512, 0.0375893 \u2026 0.0375893, 0.0405512, 0.0434054, 0.0461519, 0.0487907, 0.0513218, 0.0537452, 0.0560608, 0.0582688, 0.0603691], Real[0.113163, 0.111058, 0.108842, 0.106515, 0.104077, 0.101528, 0.0988686, 0.0960983, 0.0932171, 0.0902252 \u2026 0.0902252, 0.0932171, 0.0960983, 0.0988686, 0.101528, 0.104077, 0.106515, 0.108842, 0.111058, 0.113163], Real[-0.5, -0.483333, -0.465789, -0.447368, -0.42807, -0.407895, -0.386842, -0.364912, -0.342105, -0.318421 \u2026 0.318421, 0.342105, 0.364912, 0.386842, 0.407895, 0.42807, 0.447368, 0.465789, 0.483333, 0.5], Real[0.0613923, 0.0593459, 0.0571918, 0.0549299, 0.0525604, 0.0500832, 0.0474982, 0.0448056, 0.0420052, 0.0390972 \u2026 0.0390972, 0.0420052, 0.0448056, 0.0474982, 0.0500832, 0.0525604, 0.0549299, 0.0571918, 0.0593459, 0.0613923], nothing) Congratulations! You've created your first wing object. If you want, you can take a moment to explore the contents of your newly created mainwing . You can do so using fieldnames(mainwing) and poking around. The Reference section will have more info on the contents of the wing object. Next, let's create a wing system. system = vlm.WingSystem() FLOWVLM.WingSystem(Any[], String[], Real[0.0, 0.0, 0.0], Real[1.0 0 0; 0 1 0; 0 0 1], Real[1.0 0 0; 0 1 0; 0 0 1], nothing, Dict{String,Any}()) You now have an empty wing system, so let's add our mainwing object to it with the name \"mainwing.\" vlm.addwing(system,\"mainwing\",mainwing) Now that we have a wing system, let's save it as a .vtk file so we can view it in paraview. In order to do so, we are required to define a freestream velocity. Vinf(x,t) = [1,0,0] vlm.setVinf(system, Vinf) We will also want to set some parameters for saving files and set up our file system to put the files where we want. run_name = \"tutorial\" save_path = \"./simplewing/\" run(`rm -rf $save_path`) run(`mkdir $save_path`) Finally, we can save the files. vlm.save(system, run_name; path=save_path) And now we can view our wing in Paraview using the command run(`paraview --data=\"$(save_path)/$(run_name)_mainwing_vlm.vtk\"`) (assuming you've set up an alias for paraview on your computer).","title":"Geometry Basics"},{"location":"tutorials/first-steps/#adding-a-rotor","text":"Now that we have a basic wing, let's go ahead and add a rotor. We'll use some data for the rotor that already exists in FLOWUnsteady. You can visit the How-to guides for more information on creating your own rotor database. rotor_file = \"apc10x7.csv\" # Rotor geometry data_path = uns.def_data_path # Path to rotor database With the rotor data, we can generate our rotor. This might take a minute or so to run. We supress the output here with a semi-colon as it prints a large output. rotor = uns.generate_rotor(rotor_file; pitch=0.0, n=10, CW=true, ReD=1.5e6, verbose=true, xfoil=false, data_path=data_path, plot_disc=false); Generating geometry... Generating airfoils... n4412-1500000.csv n4412-1500000.csv n4412-1500000.csv n4412-1500000.csv n4412-1500000.csv Generating FLOWVLM Rotor... And then we can generate a rotor object, where we again supress the output. rotors = vlm.Rotor[rotor]; This will put the rotor at the default location and orientation which we will define here since we now need to move the rotor relative to the wing which is already at this location. vehicleorigin = [0.0; 0.0; 0.0] vehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0] 3\u00d73 Array{Float64,2}: 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 To move the rotor, we need to define a new origin point. rotororigin = [-0.1; 0.0; 0.0] 3-element Array{Float64,1}: -0.1 0.0 0.0 Then we can use that origin to set the rotor coordinate system in order to move the rotor. for rotor in rotors vlm.setcoordsystem(rotor, rotororigin, vehicleaxis; user=true) end which we can put in a tuple that stores our rotor system(s). rotors_system = (rotor,); We also need to add it to our overall system. for rotor in rotors; vlm.addwing(system, run_name, rotor); end; Like setting the Vinf parameter for the main wing, we need to give our rotor an RPM as well. for rotor in rotors; vlm.setRPM(rotor, 6000); end; We should now be able to visualize our wing with a rotor. run(`rm -rf $save_path`) run(`mkdir $save_path`) vlm.save(system, run_name; path=save_path) run(`paraview --data=\"$(save_path)/tutorial_mainwing_vlm.vtk;tutorial_tutorial_Blade1_vlm.vtk;tutorial_tutorial_Blade2_vlm.vtk;tutorial_tutorial_Blade1_loft.vtk;tutorial_tutorial_Blade2_loft.vtk;\"`)","title":"Adding a Rotor"},{"location":"tutorials/first-steps/#other-systems","text":"","title":"Other Systems"},{"location":"tutorials/first-steps/#vlm-systems","text":"","title":"VLM Systems"},{"location":"tutorials/first-steps/#wake-systems","text":"","title":"Wake Systems"},{"location":"tutorials/first-steps/#tilting-systems","text":"","title":"Tilting Systems"},{"location":"tutorials/first-steps/#kinematic-maneuvers","text":"","title":"Kinematic Maneuvers"},{"location":"tutorials/first-steps/#setting-up-a-basic-simulation","text":"","title":"Setting up a Basic Simulation"},{"location":"tutorials/tutorials/","text":"Tutorials Here in the tutorials we go through step-by-step instructions for the basic usage of FLOWUnsteady. Our goal here is to get you from little/no knowledge to a basic working knowledge of how to use the code. Tutorials follow a pattern of copy/pasting commands and comparing expected output. The current list of tutorials can be found below, but before you get started, you need to install the code. In addition, the majority of graphical outputs are for visualization in Paraview. Go to the Getting Started an Paraview Visualiztion how-to guides to get everything set up, then come back here to learn how to start using FLOWUnsteady.","title":"Tutorials"},{"location":"tutorials/tutorials/#tutorials","text":"Here in the tutorials we go through step-by-step instructions for the basic usage of FLOWUnsteady. Our goal here is to get you from little/no knowledge to a basic working knowledge of how to use the code. Tutorials follow a pattern of copy/pasting commands and comparing expected output. The current list of tutorials can be found below, but before you get started, you need to install the code. In addition, the majority of graphical outputs are for visualization in Paraview. Go to the Getting Started an Paraview Visualiztion how-to guides to get everything set up, then come back here to learn how to start using FLOWUnsteady.","title":"Tutorials"}]}