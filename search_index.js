var documenterSearchIndex = {"docs":
[{"location":"tutorials/first-steps/#First-Steps-1","page":"First Steps","title":"First Steps","text":"","category":"section"},{"location":"tutorials/first-steps/#Geometry-Basics-1","page":"First Steps","title":"Geometry Basics","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"In this tutorial, we'll begin by defining the geometry for a simple wing.  Note that all the functions used are described in the Reference section of this documentation if you would like further information at any point.  Before you begin this tutorial, it is expected that you've already installed the necessary components of FLOWUnsteady, and that you are familiar with visualization in Paraview.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"First things first, we need to include the FLOWUnsteady components","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"import FLOWUnsteady\nuns = FLOWUnsteady\nvlm = uns.vlm\n\nspan = 1.0              #wing span\naspectratio = 10.0      #wing aspect ratio\ntaperratio = 0.5        #wing taper ratio\nwingtwist = 0.0         #wing twist\nwingsweep = 10.0        #wing sweep in degrees\nwingdihedral = 7.0      #wing dihedral in degrees","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"import FLOWUnsteady\nuns = FLOWUnsteady\nvlm = uns.vlm","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Let's begin with a single section, symmetric wing.  We'll start by defining some basic geometry.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"span = 1.0              #wing span\naspectratio = 10.0      #wing aspect ratio\ntaperratio = 0.5        #wing taper ratio\nwingtwist = 0.0         #wing twist\nwingsweep = 10.0        #wing sweep in degrees\nwingdihedral = 7.0      #wing dihedral in degrees","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Then we'll call the simpleWing() function to create a simple wing object.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"mainwing = vlm.simpleWing(span,aspectratio,taperratio,wingtwist,wingsweep,wingdihedral)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Congratulations! You've created your first wing object.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"info: Exploring wing objects\nIf you want, you can take a moment to explore the contents of your newly created mainwing.  You can do so using fieldnames(mainwing) and poking around. The Reference section will have more info on the contents of the wing object.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Next, let's create a wing system.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"system = vlm.WingSystem()","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"You now have an empty wing system, so let's add our mainwing object to it with the name \"mainwing.\"","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"vlm.addwing(system,\"mainwing\",mainwing)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Now that we have a wing system, let's save it as a .vtk file so we can view it in paraview.  In order to do so, we are required to define a freestream velocity.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Vinf(x,t) = [1,0,0]         #non-dimensional function defining free stream velocity\nvlm.setVinf(system, Vinf)   #set freestream velocity for the system","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We will also want to set some parameters for saving files and set up our file system to put the files where we want.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"danger: Be careful with rm\nMake sure you have set your save_path to something non-important so the rm command doesn't delete anything you'll miss.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"run_name = \"tutorial\"           #define identifier at beginning of file names\nsave_path = \"./simplewing/\"     #define directory where files will be saved\n\nrun(`rm -rf $save_path`)        #clear out directory where files will be saved\nrun(`mkdir $save_path`)         #re-create directory fresh","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Finally, we can save the files.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"vlm.save(system, run_name; path=save_path)  #save geometry in a .vtk file format","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"And now we can view our wing in Paraview using the command run(`paraview --data=\"$(save_path)/$(run_name)_mainwing_vlm.vtk\"`) (assuming you've set up an alias for paraview on your computer).","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"(Image: basic wing)","category":"page"},{"location":"tutorials/first-steps/#Adding-a-Rotor-1","page":"First Steps","title":"Adding a Rotor","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Now that we have a basic wing, let's go ahead and add a rotor.  We'll use some data for the rotor that already exists in FLOWUnsteady.  You can visit the How-to guides for more information on creating your own rotor database.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"rotor_file = \"apc10x7.csv\"          # Rotor geometry\ndata_path = uns.def_data_path       # Path to rotor database","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"With the rotor data, we can generate our rotor. This might take a minute or so to run. We supress the output here with a semi-colon as it prints a large output.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"rotor_file = \"apc10x7.csv\"          # hide\ndata_path = uns.def_data_path       # hide\n\nR, B = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]] #get the radius for later\n\nrotor = uns.generate_rotor(rotor_file; pitch=0.0,\n                                            n=10, CW=true, ReD=1.5e6,\n                                            verbose=true, xfoil=true,\n                                            data_path=data_path,\n                                            plot_disc=false);","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"And then we can generate a rotor object, where we again supress the output.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"rotors = vlm.Rotor[rotor];","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"This will put the rotor at the default location and orientation which we will define here since we now need to move the rotor relative to the wing which is already at this location.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"vehicleorigin = [0.0; 0.0; 0.0]\nvehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"To move the rotor, we need to define a new origin point.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"rotororigin = [-0.1; 0.0; 0.0]","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Then we can use that origin to set the rotor coordinate system in order to move the rotor.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"for rotor in rotors\n    vlm.setcoordsystem(rotor, rotororigin, vehicleaxis; user=true)\nend","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"which we can put in a tuple that stores our rotor system(s).","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"rotor_systems = (rotors,);","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We also need to add it to our overall system.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"for rotor in rotors; vlm.addwing(system, run_name, rotor); end;","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Like setting the Vinf parameter for the main wing, we need to give our rotor an RPM as well.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"RPMref = 6000       #reference RPM\nfor rotor in rotors; vlm.setRPM(rotor, RPMref); end;","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We should now be able to visualize our wing with a rotor.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"run(`rm -rf $save_path`)\nrun(`mkdir $save_path`)\n\nvlm.save(system, run_name; path=save_path)\nrun(`paraview --data=\"$(save_path)/tutorial_mainwing_vlm.vtk;tutorial_tutorial_Blade1_vlm.vtk;tutorial_tutorial_Blade2_vlm.vtk;tutorial_tutorial_Blade1_loft.vtk;tutorial_tutorial_Blade2_loft.vtk;\"`)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"(Image: wing with rotor)","category":"page"},{"location":"tutorials/first-steps/#Other-Systems-1","page":"First Steps","title":"Other Systems","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"In order run an analysis with our little airplane, we're going to have to add a few more systems","category":"page"},{"location":"tutorials/first-steps/#VLM-Systems-1","page":"First Steps","title":"VLM Systems","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"First let's create a VLM system and add our main wing to it.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"vlm_system = vlm.WingSystem()\n\nvlm.addwing(vlm_system, \"mainwing\", mainwing)","category":"page"},{"location":"tutorials/first-steps/#Wake-Systems-1","page":"First Steps","title":"Wake Systems","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Next, let's create a wake system and add both the VLM system and rotor.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"wake_system = vlm.WingSystem()\n\nvlm.addwing(wake_system, \"SolveVLM\", vlm_system)\n\nfor rotor in rotors; vlm.addwing(wake_system, run_name, rotor); end;","category":"page"},{"location":"tutorials/first-steps/#Tilting-Systems-1","page":"First Steps","title":"Tilting Systems","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We'll also need to identify tilting objects, but since we don't have any tilting components yet, we'll just initialize an empty tuple. For more information on adding tilting objects (like control surfaces, or tilt-wings) see How to Define Vehicle Systems.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"tilting_systems = ();","category":"page"},{"location":"tutorials/first-steps/#Kinematic-Maneuvers-1","page":"First Steps","title":"Kinematic Maneuvers","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Now let's define our maneuver. For now, let's just have the airplane fly in a straight and level. We are going to have to define non-dimensional functions for the velocity for the vehicle, the angle for the vehicle, the angles for our tilting systems, and the rotation rate for the rotor(s).","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"info: Non-dimensionalized Functions\nThe functions that define the kinematic maneuver must be defined non-dimensionally. For more information on this, see How to Define Kinematic Maneuvers.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We'll start with the vehicle velocity function.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Vvehicle(t) = [-1.0,0.0,0.0]","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Next, let's define the vehicle angle.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"anglevehicle(t) = zeros(3)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Now the angle of the titling systems (we don't have any, so it's just empty again).","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"angle = ();","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Lastly, we need to define a rotation rate function for each of the rotors.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"RPM_fun(t) = 1.0\n\nRPM = (RPM_fun, );","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"With all the individual elements defined, we can create a maneuver","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"maneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We can also plot the maneuver to quickly see what we made.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"uns.plot_maneuver(maneuver)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"A plot of the maneuver is helpful, but visualizing in Paraview can also be helpful. In order to do that, however, we first need to set up a simulation.","category":"page"},{"location":"tutorials/first-steps/#Setting-up-a-Basic-Simulation-1","page":"First Steps","title":"Setting up a Basic Simulation","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We already have most of the elements we need to define a simulation, but need to create a vehicle to be used in the simulation with the systems we've already defined.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"vehicle = uns.VLMVehicle(   system;\n                            tilting_systems = tilting_systems,\n                            rotor_systems   = rotor_systems,\n                            vlm_system      = vlm_system,\n                            wake_system     = wake_system,\n                        );","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"In addition, we still need to define a reference velocity, the total time for the simulation, and a few initial conditions.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Vref = 10.0         #define a reference velocity for the vehicle\nttot = 1.0          #define a total simulation time, in seconds\nnsteps = 300        #define the number of steps the simulation will take\n\n#initial conditions\ntinit = 0.0                                  #initial time\nVinit = Vref*maneuver.Vvehicle(tinit/ttot)   #initial linear velocity\nWinit = zeros(3)                             #initial angular velocity","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"With everything now defined, we can create a simulation","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot; Vinit=Vinit, Winit=Winit, t=tinit);","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"Finally, we can visualize the maneuver in Paraview.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"files = uns.visualize_kinematics(   simulation, nsteps, save_path;\n                                    run_name=run_name,\n                                    prompt=false,\n                                    paraview=false\n                                )\n\nrun(`paraview --data=\"$save_path/$files\"`)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"(Image: moving wing and rotor)","category":"page"},{"location":"tutorials/first-steps/#Running-the-Simulation-1","page":"First Steps","title":"Running the Simulation","text":"","category":"section"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"We also now run the simulation and use Paraview to look at the outputs.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"note: Outputs\nWe are only outputting the basic pressure field here. In order to have additional outputs, it is necessary to write some extra runtime functions, see How to Set up Run-time Functions for more information.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"note: Run Time\nRunning simulations typcially takes a while.  You may want to reduce nsteps, but the visual below shows results for 300 steps.","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"nullfunc(args...) = false\npfield = uns.run_simulation(simulation, nsteps;\n                                    surf_sigma=R/10,\n                                    Vinf=Vinf,\n                                    save_path=save_path,\n                                    run_name=run_name,\n                                    prompt=false,\n                                    verbose=true,\n                                    extra_runtime_function=nullfunc\n                                    )\n\nrun(`paraview --data=\"$save_path/$(files);tutorial_pfield...vtk\"`)","category":"page"},{"location":"tutorials/first-steps/#","page":"First Steps","title":"First Steps","text":"(Image: pressure field)","category":"page"},{"location":"reference/FLOWVLMfunctions/#Functions-Contained-in-FLOWVLM-1","page":"Functions Contained in FLOWVLM","title":"Functions Contained in FLOWVLM","text":"","category":"section"},{"location":"reference/FLOWVLMfunctions/#","page":"Functions Contained in FLOWVLM","title":"Functions Contained in FLOWVLM","text":"Modules = [FLOWUVLM]\nOrder   = [:function, :type]","category":"page"},{"location":"how-to-guide/paraview-visualization/#Visualize-with-Paraview-1","page":"Visualize with Paraview","title":"Visualize with Paraview","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/#How-to-Define-Kinematic-Maneuvers-1","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"","category":"section"},{"location":"reference/FLOWUnsteadyfunctions/#Functions-Contained-in-FLOWUnsteady-1","page":"Functions Contained in FLOWUnsteady","title":"Functions Contained in FLOWUnsteady","text":"","category":"section"},{"location":"reference/FLOWUnsteadyfunctions/#","page":"Functions Contained in FLOWUnsteady","title":"Functions Contained in FLOWUnsteady","text":"Modules = [FLOWUnsteady]\nOrder   = [:function, :type]","category":"page"},{"location":"how-to-guide/define-complex-wings/#How-to-define-Complex-Wings-1","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"In the tutorial First Steps we introduced the simpleWing() function.  In this guide, we look at creating more complex wings using the complexWing() function. Note that this is a how to guide, showing how to use the complexWing() function. For details on this function implementation, please refer to the refernce section of this documentation.","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-a-Symmetric-Wing-1","page":"How to define Complex Wings","title":"Define a Symmetric Wing","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"In order to use the complexWing() function, we only need to understand that we are responsible for defining the elements of each chord section individually, which gives us greater flexibility than the simpleWing() function, where many assumptions are made for the user.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Let us begin by defining some of the wing parameters","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Now let's define the parameters of each chord.  Note that position is normalized by the span, and length is normalized by the tip chord. It is generally easiest to define things absolutely and then normalize.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Also Since we are creating a symmetric wing, we only need information from the center to the tip of the wing, postive indicating along the positive axis for the wing system.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"poschord = [0.0; 0.5; 1.0]./span                    #postion of chord stations\nlengthtipchord = 0.03                               #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                       #twist of chords, in degrees","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Then let's define the parameters of each section between chord definitions.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"sweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"We also need to define the aspect ration of the wing, which is simply the absolute span over the absolute tip chord length.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"aspectratio = span/lengthtipchord","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"With this, we can call the complexWing() function for a symmetric wing.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"mainwing = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"(Image: symmetric wing)","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-a-Non-symmetric-Wing-1","page":"How to define Complex Wings","title":"Define a Non-symmetric Wing","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"A good example of a non-symmetric wing is something like a vertical stabilizer. The definitions are basically the same, we just set the symmetric flag to false when creating the wing.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 0.25                             #length of full span\nnumlattice = 5                          #number of lattice elements on half-span\nposchord = [0.0; 1.0]                   #postion of chord stations\nlengthtipchordvstab = 0.05              #length of tip chord\nlengthchordvstab = [1.25; 1.0]          #length of chords\ntwistchord = [0.0; 0.0]                 #twist of chords, in degrees\nsweepsection = [0.0]                    #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                 #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"note: Chord Alignment\nThe user can choose where to align the chords. A value of 0.0 aligns along the leading edge, while a value of 1.0 aligns along the trailing edge. Values between 0.0 and 1.0 will align along that ratio of the chord lengths.  For example, if you wanted to align the wing along the quarter-chord postition, you would set cordalign = 0.25","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Now our verticle stabilizer is defined, but it's not really verticle yet, and it is positioned at the default location, where our main wing is as well.  To make it a verticle stabilizer, we'll need to rotate and translate it.  To do so, we need to define an origin and coordinate system for the verticle stabilizer wing object.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"originvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Then we can set the coordianate system.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"vlm.setcoordsystem(verticalstabilizer,originvstab,csysvstab)","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"(Image: non-symmetric wing)","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-Control-Surfaces-1","page":"How to define Complex Wings","title":"Define Control Surfaces","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"There is no automatic way to define control surfaces. Each control surface will need to be defined as its own wing object and placed manually. Therefore, you must adjust based on the objects already in place. Let's add a rudder to our verticle stabilizer.","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 0.25                        #length of full span\nnumlattice = 5                     #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]        #postion of chord stations\nlengthtipchord = 0.03              #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]       #twist of chords, in degrees\nsweepsection = [0.0; 0.0]          #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]       #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]  #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(rudder,originrudder,csysrudder)","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"(Image: rudder)","category":"page"},{"location":"how-to-guide/define-complex-wings/#","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span\n\nposchord = [0.0; 0.5; 1.0]./span                #postion of chord stations\nlengthtipchord = 0.03                            #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                   #twist of chords, in degrees\nsweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nmainwing = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)\n\n\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 1.0]                #postion of chord stations\nlengthtipchordvstab = 0.05                          #length of tip chord\nlengthchordvstab = [1.25; 1.0]     #length of chords\ntwistchord = [0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)\n\noriginvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(verticalstabilizer,originvstab,csysvstab)\n\n\n\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]                #postion of chord stations\nlengthtipchord = 0.03                          #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0; 0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]                       #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(rudder,originrudder,csysrudder)\n\n\nsystem = vlm.WingSystem()\nvlm.addwing(system,\"mainwing\",mainwing)\nvlm.addwing(system,\"vstab\",verticalstabilizer)\nvlm.addwing(system,\"rudder\",rudder)\n\nVinf(x,t) = [1,0,0]         #non-dimensional function defining free stream velocity\nvlm.setVinf(system, Vinf)   #set freestream velocity for the system\n\nrun_name = \"tutorial\"           #define identifier at beginning of file names\nsave_path = \"./simplewing/\"     #define directory where files will be saved\n\nrun(`rm -rf $save_path`)        #clear out directory where files will be saved\nrun(`mkdir $save_path`)         #re-create directory fresh\n\nvlm.save(system, run_name; path=save_path)  #save geometry in a .vtk file format\nrun(`paraview`)","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-things-Manually-1","page":"How to define Complex Wings","title":"Define things Manually","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/#How-to-Set-up-Run-time-Functions-1","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"FLOWUnsteady allows for the definition of additional run-time functions, which are passed into the keyword argument, extra_runtime_function, in the run_simulation() function.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"These are typically formatted as follows:","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"function customfunction(inputs)\n\n    function extra_runtime_function(sim, pfield, t, dt)\n\n        #insert your function here\n\n        return false\n\n    end\n\nend","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"If you have more than one additional function you'd like to run, a nice way for allowing arbitrarily defined functions is to define an encapsulating functions with the args... command such as","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"customfunc1 = customfunction1(inputs1)\ncustomfunc2 = customfunction2(inputs2)\nextrafunctions(args...) = customfunc1(args...) || customfunc2(args...)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#Creating-Monitors-1","page":"How to Set up Run-time Functions","title":"Creating Monitors","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"By incorporating plots into an extra runtime function, you can create monitors that will show you the progress of the simulation.  The definition of these very much depends on your use case. For the creators, aerodynamic forces are important, so we'll cover that now.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#Calculating-Aerodynamic-Forces-1","page":"How to Set up Run-time Functions","title":"Calculating Aerodynamic Forces","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"FLOWUnsteady has some functions that assist in calculating aerodynamic forces.  Specifically, the calc_aerodynamicforces() function and the decompose() function.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"To get the total forces on a wing object, you need the current and previous wing state, as well as the freestream velocity and density.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"Ftot = uns.calc_aerodynamicforces(currentwingobject,priorstepwingobject, pfield, Vinf, dt, rhoinf)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"note: Previous Wing\nIn order to save the previous wing, it is convenient to initialize prevwing to nothing before entering the extraruntime function, and using deep copy at the end of the extra runtime function (before returning false).function customfunc(inputs)\n\n    prev_wing = nothing\n\n    extra_runtime_function(sim,pfield,t,dt)\n\n        #custom function\n\n        prev_wing = deepcopy(wing)\n\n        return false\n\n    end\n\nend","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"This gives you the total forces on the overall wing. If you want the forces on each section of the wing, you'd have to set the per_unit_span boolean keyword argument to true","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"ftot = uns.calc_aerodynamicforces(currentwingobject,priorstepwingobject, pfield, Vinf, dt, rhoinf; per_unit_span=true)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"To get the respective Lift, Drag, and Sideslip forces, you need to pass the total force vector into the decompose() function along with two orthogonal vectors indicating what direction the forces are acting.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"For example, for steady, level flight in the typical aerodynamics frame, you could do","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"L, D, S = uns.decompose(Ftot,[0,0,1],[1,0,0])","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"Where lift is in the positive z-direction, or [0,0,1] and drag is in the positive x-direction, or [1,0,0].  The decompose function only needs the directions for the first two outputs, and then it calculates the third vector.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"note: Arbitrary Force Vectors\nBecause of how the decompose function is defined, you have no limits on what forces you calculate. That is to say, you can find the forces in any reference frame.  This also makes the user responsible for defining exactly what they want to use as the Lift vector, etc.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#Adding-data-to-output-files-1","page":"How to Set up Run-time Functions","title":"Adding data to output files","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"By passing, say, a wing object into an extra runtime function, you can use the _addsolution() function in the VLM module to add data to the .vtk files output by the simulation.  This way, you can visualize in Paraview things such as forces and velocities in addition to the default outputs.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"For example, if you had calculated Lift and Drag, and wanted to include those in the files used in Paraview visualization you could run the commands","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"vlm._addsolution(wingobject,\"Lift\",Lift)\nvlm._addsolution(wingobject,\"Drag\",Drag)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"You can also write data to other files that you define yourself.  For example, if you wanted to save the lift and drag coefficients in a .csv file for easy plotting later, you would simply open a file, write to it, and close it as one would normally do.","category":"page"},{"location":"how-to-guide/define-complex-systems/#How-to-Define-Vehicle-Systems-1","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"In this guide, we will cover how to define complex systems. Basic system definitions were presented in the First Steps tutorial, but applications quickly become more complex than a simple, control-free wing.","category":"page"},{"location":"how-to-guide/define-complex-systems/#Wing-Subsystems-1","page":"How to Define Vehicle Systems","title":"Wing Subsystems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"We will first cover creating wing subsystems.  The key here is that any system can be a sub-system. Take, for example, the vertical stabilizer and rudder from How to define Complex Wings which we can define a add to a wing system.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"#Vertical Stabilizer\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 1.0]                #postion of chord stations\nlengthtipchordvstab = 0.05                          #length of tip chord\nlengthchordvstab = [1.25; 1.0]     #length of chords\ntwistchord = [0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)\n\noriginvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(verticalstabilizer,originvstab,csysvstab)\n\n\n#Rudder\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]                #postion of chord stations\nlengthtipchord = 0.03                          #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0; 0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]                       #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(rudder,originrudder,csysrudder)\n\n\n#System Definition\ntail = vlm.WingSystem()\nvlm.addwing(tail,\"vstab\",verticalstabilizer)\nvlm.addwing(tail,\"rudder\",rudder)","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Now we might want that tail system to be part of a full system, so let's define the main wing and add both it and the tail system to the full system.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"#Main Wing\nspan = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span\n\nposchord = [0.0; 0.5; 1.0]./span                #postion of chord stations\nlengthtipchord = 0.03                            #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                   #twist of chords, in degrees\nsweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nmainwing = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)\n\n\n#System Definition\nsystem = vlm.WingSystem()\nvlm.addwing(system,\"mainwing\",mainwing)\nvlm.addwing(system,\"tail\",tail)","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"And that's all there is to it. The main wing and tail system are now both components of the overall system. Any combination of wing objects and wing systems can be added to any system.","category":"page"},{"location":"how-to-guide/define-complex-systems/#VLM-Systems-1","page":"How to Define Vehicle Systems","title":"VLM Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Anything that will be solved using the VLM (see Reference) needs to be identified as such. In our case, all the wings fall under this category.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"vlm_system = vlm.WingSystem()\nvlm.addwing(vlm_system,\"mainwing\",mainwing)\nvlm.addwing(vlm_system,\"tail\",tail)","category":"page"},{"location":"how-to-guide/define-complex-systems/#Wake-Systems-1","page":"How to Define Vehicle Systems","title":"Wake Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"You need to tell the solver which of the systems you've created need to be included in the wake simulation.  In this case, we want everything to be in our wake system, which is defined just like before.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"wake_system = vlm.WingSystem()\nvlm.addwing(wake_system,\"mainwing\",mainwing)\nvlm.addwing(wake_system,\"tail\",tail)","category":"page"},{"location":"how-to-guide/define-complex-systems/#Rotor-Systems-1","page":"How to Define Vehicle Systems","title":"Rotor Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Rotor systems begin with rotors, the definition of which is covered in How to Define a Custom Rotor.  Once you have rotors defined with their respetive databases, you can create rotor systems.  Let's add two rotors to our airplane in this guide to see how it is done.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"First let's decide where we want to place the rotors.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"posrotorplus = [0.0; 0.25; 0.0]      #xyz position of rotor in positive y-direction\nposrotorminus = -posrotorplus       #xyz position of rotor in negative y-direction\nvehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]   #default coordinate system","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"We need a few more parameters for defining rotors as well.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"rotor_file = \"apc10x7.csv\"          # data file for rotor\ndata_path = uns.def_data_path       # data path to find file\n\nR, B = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]] #grab rotor radius\nn = 100.0                           #target RPS\nVref = 20.0                         #freestream velocity\nvind = sqrt( Vref^2 + (n*R)^2 )     #velocity at blade tip\nrho = 1.225                         #(kg/m^3) air density\nmu = 1.81e-5                        #(kg/ms) air dynamic viscosity\nReD = rho*2.0*R*vind/mu             #Diameter-based Reynolds\n\nnumbladeelements = 10               #number of blade elements\nrotorpitch = 0.0                    #rotor pitch","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Now we are ready to define some propellers.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"rotors = vlm.Rotor[]\n\npush!(rotors,\n        uns.generate_rotor(rotor_file;\n                            pitch=rotorpitch,\n                            n=numbladeelements,\n                            CW=true,\n                            ReD=ReD,\n                            verbose=true,\n                            xfoil=false,\n                            data_path=data_path)\n    )\n\n\npush!(rotors,\n        vlm.Rotor(!rotors[1].CW,\n                    rotors[1].r,\n                    rotors[1].chord,\n                    rotors[1].theta,\n                    rotors[1].LE_x,\n                    rotors[1].LE_z,\n                    rotors[1].B,\n                    rotors[1].airfoils))\n\nvlm.initialize(rotors[2], rotors[1].m)\n\nvlm.setcoordsystem(rotors[1], posrotorminus, vehicleaxis; user=true)\nvlm.setcoordsystem(rotors[2], posrotorplus, vehicleaxis; user=true)","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Now that we have defined our rotors, we can add them to the other systems","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"for (i, rotor) in enumerate(rotors)\n    vlm.addwing(system, \"rotor$i\", rotor)\n    vlm.addwing(wake_system, \"Rotor$i\", rotor)\nend","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"note: Repeated Object Names\nYou can only use a specific name in one system. Note how in the example above, rotor$i is used for the main system, and captial Rotor$i is used for the wake system","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Finally, we need to create our rotor system, which is actually just a tuple of the rotor object we've already created.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"rotor_systems = (rotors, )","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"(Image: )","category":"page"},{"location":"how-to-guide/define-complex-systems/#Tilting-Systems-1","page":"How to Define Vehicle Systems","title":"Tilting Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"A tilting system is simply a tuple of all the wing systems that will be rotating according to specific definitions beyond the overall aircraft orientations. In our case, that would just be the rudder.","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"tilting_systems = (rudder, )","category":"page"},{"location":"how-to-guide/define-complex-systems/#","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"#Vertical Stabilizer\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 1.0]                #postion of chord stations\nlengthtipchordvstab = 0.05                          #length of tip chord\nlengthchordvstab = [1.25; 1.0]     #length of chords\ntwistchord = [0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)\n\noriginvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(verticalstabilizer,originvstab,csysvstab)\n\n\n#Rudder\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]                #postion of chord stations\nlengthtipchord = 0.03                          #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0; 0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]                       #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(rudder,originrudder,csysrudder)\n\n\n#System Definition\ntail = vlm.WingSystem()\nvlm.addwing(tail,\"vstab\",verticalstabilizer)\nvlm.addwing(tail,\"rudder\",rudder)\n\n#Main Wing\nspan = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span\n\nposchord = [0.0; 0.5; 1.0]./span                #postion of chord stations\nlengthtipchord = 0.03                            #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                   #twist of chords, in degrees\nsweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nmainwing = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)\n\n\n#System Definition\nsystem = vlm.WingSystem()\nvlm.addwing(system,\"mainwing\",mainwing)\nvlm.addwing(system,\"tail\",tail)\n\n\n\n\nposrotorplus = [0.0; 0.25; 0.0]      #xyz position of rotor in positive y-direction\nposrotorminus = -posrotorplus       #xyz position of rotor in negative y-direction\nvehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]   #default coordinate system\n\n\n\n\nrotor_file = \"apc10x7.csv\"          # data file for rotor\ndata_path = uns.def_data_path       # data path to find file\n\nR, B = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]] #grab rotor radius\nn = 100.0                           #target RPS\nVref = 20.0                         #freestream velocity\nvind = sqrt( Vref^2 + (n*R)^2 )     #velocity at blade tip\nrho = 1.225                         #(kg/m^3) air density\nmu = 1.81e-5                        #(kg/ms) air dynamic viscosity\nReD = rho*2.0*R*vind/mu             #Diameter-based Reynolds\n\nnumbladeelements = 10               #number of blade elements\nrotorpitch = 0.0                    #rotor pitch\n\n\nrotors = vlm.Rotor[]\n\npush!(rotors,\n        uns.generate_rotor(rotor_file;\n                            pitch=rotorpitch,\n                            n=numbladeelements,\n                            CW=true,\n                            ReD=ReD,\n                            verbose=true,\n                            xfoil=false,\n                            data_path=data_path)\n    )\n\n\npush!(rotors,\n        vlm.Rotor(!rotors[1].CW,\n                    rotors[1].r,\n                    rotors[1].chord,\n                    rotors[1].theta,\n                    rotors[1].LE_x,\n                    rotors[1].LE_z,\n                    rotors[1].B,\n                    rotors[1].airfoils))\n\nvlm.initialize(rotors[2], rotors[1].m)\n\nvlm.setcoordsystem(rotors[1], posrotorminus, vehicleaxis; user=true)\nvlm.setcoordsystem(rotors[2], posrotorplus, vehicleaxis; user=true)\n\n\n\nfor (i, rotor) in enumerate(rotors)\n    vlm.addwing(wake_system, \"rotor$i\", rotor)\nend\n\n\n\n\nVinf(x,t) = [1,0,0]         #non-dimensional function defining free stream velocity\nvlm.setVinf(system, Vinf)   #set freestream velocity for the system\nRPMref = 6000       #reference RPM\nfor rotor in rotors; vlm.setRPM(rotor, RPMref); end;\n\nrun_name = \"tutorial\"           #define identifier at beginning of file names\nsave_path = \"./simplewing/\"     #define directory where files will be saved\n\nrun(`rm -rf $save_path`)        #clear out directory where files will be saved\nrun(`mkdir $save_path`)         #re-create directory fresh\n\nvlm.save(system, run_name; path=save_path)  #save geometry in a .vtk file format\nrun(`paraview`)","category":"page"},{"location":"tutorials/getting-started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"how-to-guide/wake-stability/#How-to-Approach-Wake-Stability-Issues-1","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"","category":"section"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"The vortex particle method does pretty well until a wake reaches turbulent breakdown, at which point the solver can become unstable.  There are several ways to try to maintain stability.  Some include inherent object physics, others have to do with simulation parameters, and others involve removing particles from the simulation.  The following are some things that the users have encountered and found helpful.","category":"page"},{"location":"how-to-guide/wake-stability/#Inherent-Physics-1","page":"How to Approach Wake Stability Issues","title":"Inherent Physics","text":"","category":"section"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"The inherent physics of the problem may lead to turbulent breakdown happening sooner or later.  For example, there is a direct relationship between number of rotor blades and when breakdown happens.  The more blades there are, the sooner breakdown will occur.  In addition, the higher the tipspeed ratio, the sooner breakdown will occur.  Some instances of turbulent breakdown are therefore unavoidable, and the user should be aware of this limitation.","category":"page"},{"location":"how-to-guide/wake-stability/#Simulation-Parameters-1","page":"How to Approach Wake Stability Issues","title":"Simulation Parameters","text":"","category":"section"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"Sometimes, changing the simulation parameters can help keep things numerically stable for longer.  For example, the resoultion of the simulation, that is, the number and spacing of the horseshoes and particles can affect stability.","category":"page"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"In addition, there are some relaxation parameters available in the various solvers that can improve or worsen stability.  Referring to the reference section of this documentation will reveal what parameters there are and what they are for. Some of the papers cited in the Theory section also indicate some recommended parameters.","category":"page"},{"location":"how-to-guide/wake-stability/#Wake-Trimming-1","page":"How to Approach Wake Stability Issues","title":"Wake Trimming","text":"","category":"section"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"One method to maintain stability is to remove some of the wake particles.  This is done using an extra runtime function described in How to Set up Run-time Functions.","category":"page"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"Let's say you wanted to remove the particles after a certain point behind your vehicle. One way you could do this is to obtain the location of an object in your system, let's say a rotor, and then delete the particles behind a certain point relative to that location.","category":"page"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"rotors = vcat(sim.vehicle.rotor_systems...) #get rotors from simulation\norigin = rotors[1]._wingsystem.O            #choose an object origin\nrefxaxis = rotors[1]._wingsystem.Oaxis[1,:] #get the origin axis\n\n#loop through all the particles and delete if behind cuttoff point\nfor i in vpm.get_np(pfield):-1:1\n    particleposition = vpm.get_x(pfield, i) #obtain particle absolute position\n    particlevector = particlepostition - origin #obtain particle vector relative to origin\n\n    #delete if dinstance from orgin in x-direction is greater than cutoff\n    if abs(dot(particlevector,refxaxis)) > cutoffcriteria\n        vpm.delparticle(pfield, i)\n    end\nend","category":"page"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"You could also just remove everything a certain distance from your origin of choice, which would take everything other than a sphere around that object.","category":"page"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"Furthermore, you can define more advanced cutoff criteria, but special consideration may be in order.  For example, some systems rotate (like rotors and tilting systems) so their coordinate systems also rotate in time.  So if you wanted to delete particles outside a certain boundary from a rotor, you could do so for a cylindrical boundary.","category":"page"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"refyaxis = rotors[1]._wingsystem.Oaxis[2, :] # reference y axis\nrefzaxis = rotors[1]._wingsystem.Oaxis[3, :] # reference z axis\n\n#calculate the radial position of the particle\nradialpos = (sqrt(dot(parvec,refyaxis)^2 + dot(parvec,refzaxis)^2)","category":"page"},{"location":"how-to-guide/wake-stability/#","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"The Reference section of this documentation will cover all the fields in the wing system objects available to the user. How they are used, and what cutoff criteria in needed depends on the specific use and the user's desires.","category":"page"},{"location":"theory/FLOWVLMtheory/#FLOWVLM-1","page":"FLOWVLM","title":"FLOWVLM","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"FLOWVLM is a vortex lattice method (VLM) code for solving aerodynamics, but is far more than that. FLOWVLM has a general three-dimensional geometric engine that powers much of the geometry of FLOWUnsteady and is also the foundation of the blade-element rotor solver. In this section we describe how wing geometries are defined, how multiple wings can be grouped into a wing system, and how objects can be rotated and translated in space.","category":"page"},{"location":"theory/FLOWVLMtheory/#Wing-Definition-1","page":"FLOWVLM","title":"Wing Definition","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"A FLOWVLM.Wing object is simply a data structure that encapsulates a collection of horseshoes vortices (or a vortex lattice). A horseshoe vortex is made out of one bound vortex located at the quarter-chord position, two trailing bound vortices going back to the trailing edge, and two semi-infinite vortices extending from the trailing edge out in the direction of the freestream, as shown below.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"<img src=\"../assets/theoryfigs/horseshoe00.png\" alt=\"drawing\" width=\"400\" />","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"A control point is associated to every horseshoe, which is located at the three-quarter chord position. At this point, the no-flow-through boundary condition is imposed, canceling the component of the freestream that is normal to the surface.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"note: Unsteady wake\nIn the unsteady solver of FLOWUnsteady, semi-infinite trailing vortices of the horseshoes are replaced by vortex particles that are shed off the trailing edge at every time step.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"There are three ways of defining a VLM wing. The first one is to manually add chord stations along the wing and discretize the sections in between into horseshoes. This approach is tedious and is rarely used. The second one is through the function FLOWVLM.SimpleWing that takes the parameters of the root and tip of the wing and interpolates and discretizes everything in between, which works well for most conventional wings. Finally, for complex geometries (for instance, an asymmetric wing or a wing with winglets), the user can call FLOWVLM.ComplexWing that works pretty much like the option of manually building the wing but in a friendlier way.","category":"page"},{"location":"theory/FLOWVLMtheory/#Manually-Building-the-Wing-1","page":"FLOWVLM","title":"Manually Building the Wing","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"You can build a wing by adding each chord station manually and indicating the discretization in between.   This is done by indicating the leading edge position and chord length at each station, and the number of horseshoes in between stations.   This approach uses the FLOWVLM.Wing constructor to initialize the wing and the FLOWVLM.addwing function to add each chord.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"FLOWVLM.Wing","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"FLOWVLM.addchord","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"This requires the user to do all the calculations of what the geometry should look like based on the desired aspect ratio, taper ratio, etc.   In the following line we are doing such calculations for a 40^circ-swept-back wing with an aspect ratio of 5.0.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"  # Wing parameters\n  b = 98*0.0254                   # (m) span\n  ar = 5.0                        # Aspect ratio (span over tip chord)\n  tr = 1.0                        # Taper ratio\n  lambda = 45.0                   # (deg) sweep\n  gamma = 0.0                     # (deg) dihedral\n  twist_tip = 0.0                 # (deg) tip twist\n  twist_root = 0.0                # (deg) root twist\n  n = 4                           # Horseshoes in between chord stations\n\n  # Calculations\n  cr = 1/tr                       # Chord ratio (inverse of taper ratio)\n  c_tip = b/ar                    # Chord at tip\n  c_root = cr*c_tip               # Chord at root\n  y_tip = b/2                     # y-position of tip leading edge\n  x_tip = y_tip*tan(lambda*pi/180)# x-position of tip leading edge\n  z_tip = y_tip*tan(gamma*pi/180) # z-position of tip leading edge","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"We initialize the wing by giving it the first chord station, which corresponds to the left chord.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"import FLOWVLM\nvlm = FLOWVLM\n\n# Initialize the wing with the left tip chord\nwing = vlm.Wing(x_tip, -y_tip, z_tip, c_tip, twist_tip)","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"Then we go on to add the root and the right tip chord.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"  # Add the root chord\n  vlm.addchord(wing, 0.0, 0.0, 0.0, c_root, twist_root, n)\n\n  # Add the right tip chord\n  vlm.addchord(wing, x_tip, y_tip, z_tip, c_tip, twist_tip, n)","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"Notice that we placed the root at the (0, 0, 0) position.   This doesn't always have to be this way, but remember to move the other chord stations accordingly if you want to place the nose somewhere else.","category":"page"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"tip: Build wings from left to right\nIt is recommended that wings are build from left to right, or from -y to +y. Otherwise, the normals of the surface will point down in the negative z-direction and the circulation of the wing will be negative when generating upwards lift (positive z-direction). This is not a problem for the solver, but could be difficult to wrap your head around a negative circulation being associated to a positive lift.","category":"page"},{"location":"theory/FLOWVLMtheory/#SimpleWing-1","page":"FLOWVLM","title":"SimpleWing","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/#","page":"FLOWVLM","title":"FLOWVLM","text":"asdasd","category":"page"},{"location":"theory/FLOWVLMtheory/#ComplexWing-1","page":"FLOWVLM","title":"ComplexWing","text":"","category":"section"},{"location":"reference/VPMfunctions/#Functions-Contained-in-MyVPM-1","page":"Functions Contained in MyVPM","title":"Functions Contained in MyVPM","text":"","category":"section"},{"location":"reference/VPMfunctions/#","page":"Functions Contained in MyVPM","title":"Functions Contained in MyVPM","text":"Modules = [MyVPM]\nOrder   = [:function, :type]","category":"page"},{"location":"how-to-guide/define-a-rotor/#How-to-Define-a-Custom-Rotor-1","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"It is likely that the rotors defined in the repository database do not match your needs, in that case, you will need to provide all of the information to define the rotor in a series of files. The files must be defined in the correct format and directory structure for FlowUnsteady to find it all. If you are unfamiliar with creating file trees, we suggest adding your files directly to the correct directories, however a seperate file structure can easily be used.","category":"page"},{"location":"how-to-guide/define-a-rotor/#Creating-a-Custom-Rotor-1","page":"How to Define a Custom Rotor","title":"Creating a Custom Rotor","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"If you do not already have the rotor files to describe your rotor, then you will need to create them. Here we will go through each file type and what to put in them. It is important to note that file name and types are not important, however they must be comma delimited.  We will use the DJI-II from the FLOWUnsteady database as an example.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"It is important to note that if XFOIL is not run (marked false), then airfoil polars must be provided. The files that affect solution outcome are the chord distribution, pitch distribution, leading edge distribution, and airfoil polar files. If XFOIL is marked to run, all of the geometric material must be accurate.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"Below, we describe the files (and give the default file name), their contents, and provide code that can be used to create them.","category":"page"},{"location":"how-to-guide/define-a-rotor/#Main-File-(e.g.-data/rotors/DJI-II.csv)-1","page":"How to Define a Custom Rotor","title":"Main File (e.g. data/rotors/DJI-II.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"The main file describes the overall rotor, and points to the blade file that describes one of the blades.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"property file description\nRtip 0.12 (m) Radius of blade tip\nRhub 0.00823 (m) Radius of hub\nB 2 Number of blades\nblade DJI-II_blade.csv Blade file","category":"page"},{"location":"how-to-guide/define-a-rotor/#Blade-File-(e.g.-data/rotors/DJI-II_blade.csv)-1","page":"How to Define a Custom Rotor","title":"Blade File (e.g. data/rotors/DJI-II_blade.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file contains file names for the various blade definition parameters as well as parameters for spline definitions.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"property file description\nchorddist DJI-II_chorddist.csv Chord distribution\npitchdist DJI-II_pitchdist.csv Pitch distribution\nsweepdist DJI-II_sweepdist.csv LE sweep distribution\nheightdist DJI-II_heightdist.csv LE height distribution\nairfoil_files DJI-II_airfoils.csv Airfoil distribution\nspl_k 1 Spline order\nspl_s 2.0e-7 Spline smoothing","category":"page"},{"location":"how-to-guide/define-a-rotor/#Chord-Distribution-File-(e.g.-data/rotors/DJI-II_chorddist.csv)-1","page":"How to Define a Custom Rotor","title":"Chord Distribution File (e.g. data/rotors/DJI-II_chorddist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file provides the distribution of the chord along the blade, normalized by the tip radius of the blade. The file must go in order from root to tip. The root need not be defined, but the tip must be. The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R c/R\n0.0411523 0.121011\n0.0685871 0.138171\n... ...\n1.0 0.0978361","category":"page"},{"location":"how-to-guide/define-a-rotor/#Pitch-Distribution-File-(e.g.-data/rotors/DJI-II_pitchdist.csv)-1","page":"How to Define a Custom Rotor","title":"Pitch Distribution File (e.g. data/rotors/DJI-II_pitchdist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the twist of the blade along the blade. The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R twist (deg)\n0.0411523 16.4567\n0.0685871 17.5\n... ...\n1.0 11.6","category":"page"},{"location":"how-to-guide/define-a-rotor/#Sweep-Distribution-File-(e.g.-data/rotors/DJI-II_sweepdist.csv)-1","page":"How to Define a Custom Rotor","title":"Sweep Distribution File (e.g. data/rotors/DJI-II_sweepdist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the sweep distribution. This is also known as the leading edge distribution, it describes the distance of the the leading edge from a line coming from the center of the hub. These lines change depending on how many blades are included on a rotor (see photo below for example of a the rotor with 3 blades). The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"<img src=\"../assets/howtofigs/sweepdist.png\" alt=\"sweepdist\" style=\"zoom:33%;\" />","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R y/R (y-distance of LE from the middle point of hub)\n0.0411523 0.0576211\n0.0685871 0.0605955\n... ...\n1.0 0.0344412","category":"page"},{"location":"how-to-guide/define-a-rotor/#Height-Distribution-File-(e.g.-data/rotors/DJI-II_heightdist.csv)-1","page":"How to Define a Custom Rotor","title":"Height Distribution File (e.g. data/rotors/DJI-II_heightdist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the height distribution, also known as anhedral (or precode for turbines). This describes the height of the leading edge from the top face of the hub. The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"<img src=\"../assets/howtofigs/precone.png\" alt=\"precone\" width=\"400\" />","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R z/R (height of LE from the top face of hub)\n0.0686391 -0.00242965\n0.2 0.00728895\n... ...\n1.0 -0.0242965","category":"page"},{"location":"how-to-guide/define-a-rotor/#Airfoil-Section-Definition-File-(e.g.-data/rotors/DJI-II_airfoils.csv)-1","page":"How to Define a Custom Rotor","title":"Airfoil Section Definition File (e.g. data/rotors/DJI-II_airfoils.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the airfoils along the blade and the paired aerodynamic data file that goes with the contour file. The contour file is a file of the geometric shape of the airfoil. The aero file is the airfoil polar, that is, the file that has the coefficient of lift, drag and moment for a given set of angles of attack for the airfoil. Note that the information is interpolated, so airfoils between two stated airfoils will be an interpolation between the two. If XFOIL is marked to run, then the aero files will not be used. As many pairs of airfoil files as desired may be used.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R Contour file Aero file\n0.0 e856-il.csv xf-e856-il-50000-n5.csv\n0.3 e63.csv xf-e63-il-50000-n5.csv\n1.0 e63.csv xf-e63-il-50000-n5.csv","category":"page"},{"location":"how-to-guide/define-a-rotor/#Airfoil-Geometry-Files-(e.g.-data/airfoils/e63.csv)-1","page":"How to Define a Custom Rotor","title":"Airfoil Geometry Files (e.g. data/airfoils/e63.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"These files describes the geometry of the airfoil by giving x and y coordinates of the airfoil surface. These coordinates are normalized by the chord length. The order of the points should be trailing edge, upper surface, leading edge, lower surface, then trailing edge. As many coordinate pairs as desired may be used, all other points used will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"x/c y/c\n1.0 0.0\n0.99619 0.00144\n... ...\n1.0 0.0","category":"page"},{"location":"how-to-guide/define-a-rotor/#Airfoil-Polar-Files-(e.g.-data/airfoils/xf-e63-il-50000-n5.csv)-1","page":"How to Define a Custom Rotor","title":"Airfoil Polar Files (e.g. data/airfoils/xf-e63-il-50000-n5.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"These files contains all of the airfoil coefficients of lift, drag and moment for a given set of angles of attack for the airfoil. Values that are required but not given will be interpolated. Note that the polar should match the general Reynolds number that the given section will experience. If XFOIL is set to run, this file will not be used.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"Alpha Cl Cd Cdp Cm Top_Xtr Bot_Xtr\n-7.750 -0.3633 0.11634 0.10945 -0.0220 1.0000 0.0585\n-7.500 -0.3685 0.11553 0.10875 -0.0216 1.0000 0.0590\n-7.250 -0.3745 0.11473 0.10806 -0.0210 1.0000 0.0593\n... ... ... ... ... ... ...\n10.750 1.3119 0.10187 0.09684 -0.1098 0.0306 1.0000","category":"page"},{"location":"how-to-guide/define-a-rotor/#Rotor-Database-Structure-1","page":"How to Define a Custom Rotor","title":"Rotor Database Structure","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"The database can be found as a subdirectory of the FlowUnsteady package","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"../FlowUnsteady/data","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"It takes the form","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"MainFile.csv => ../data/rotors\nAirfoils.csv => ../data/rotors\nBlade.csv => ../data/rotors\nChordDist.csv => ../data/rotors\nHeightDist.csv => ../data/rotors\nPitchDist.csv => ../data/rotors\nSweepDist.csv => ../data/rotors\nAirfoilGeo_1.csv => ../data/airfoils\nAirfoilGeo_2.csv => ../data/airfoils\nAirfoilGeo_n.csv => ../data/airfoils\nAirfoilPol_1.dat => ../data/airfoils\nAirfoilPol_2.dat => ../data/airfoils\nAirfoilPol_n.dat => ../data/airfoils","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"You can point the solver to any data path, but within that data directory, you must have your files organized as above, with a rotors and airfoils subdirectory and the appropriate files in the appropriate locations.","category":"page"},{"location":"how-to-guide/define-a-rotor/#Creating-Custom-Database-Files-1","page":"How to Define a Custom Rotor","title":"Creating Custom Database Files","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"The following is an example script for creating all the necessary files in the rotor sub-directory.  Note, however, that you need to provide your own geometry and polar files to populate the airfoils sub-directory.  How you produce those is up to you, but as far as the polars are concerned, our format matches that of the XFoil output files.","category":"page"},{"location":"how-to-guide/define-a-rotor/#","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"## ----- Define Rotor Parameters ----- ##\nRPM     = 4860\nrho     = 1.225     # (kg/m^3) air density\nB       = 3         # Number of blades\nRhub    = 0.212     # (m) Radius of hub\nRtip    = 1.0       # (m) Radius of blade tip\nctip    = 0.05      # (m) tip chord length\ncroot   = .15       # (m) chord length at hub junction\nr       = range(Rhub, Rtip, length=100)         #radial stations\nrs      = range(Rhub, Rtip, length=100)./Rtip   #normalized radial stations\n\n#define chord distribution\nchord = zeros(length(r))\nfor i=1:length(r)\n    if r[i] <= 0.5*Rtip\n        chord[i] = croot\n    else\n        chord[i] = ctip + sqrt(1.0-(2*r[i]-1)^2.0)/10.0\n    end\nend\n\nchorddist = hcat(rs,chord)  #chord distribution\n\n#define pitch distribution\na1, a2  = 10, 30\nr1, r2  = 1.0, 0.225\nb       = (a2 - a1) / (1/r2 - 1/r1)\na       = a1 - b/r1\n\nth0     = 0.33200247373618086\ndthdr   = -0.28443616547899253\n\npitchdist   = hcat(rs, th0 + dthdr.*rs)     #pitch distribution\n\n#define remaining distributions\nXles        = zeros(length(rs))             #leading edge distribution\nsweepdist   = hcat(rs, Xles )               #sweep distribution\nheightdist  = hcat(rs, zeros(length(rs)) )  #height distribution\n\n\n\n## ----- Name Files ----- ##\nairfoil_file        = \"airfoils/naca0012.csv\"\ndata_path1          = \"data/rotors/\"\nsave_path1          = \"rotors\"\nrun_name            = \"rotoroldformat_try2\"\n\nrotor_filename      = \"rotorfile.csv\"\nblade_filename      = \"blade.csv\"\nairfoils_filename   = \"airfoils.csv\"\nhdist_filename      = \"heightdist.csv\"\nsdist_filename      = \"sweepdist.csv\"\npdist_filename      = \"pitchdist.csv\"\ncdist_filename      = \"chorddist.csv\"\n\n\n\n## ---- Write Files ----- ##\nrotorstring = \"property,file,description\nRtip,$Rtip, (m) Radius of blade tip\nRhub,$Rhub, (m) Radius of hub\nB,$B, Number of blades\nblade,$blade_filename, Blade file\"\n\n# Main File\nf = open(joinpath(data_path1, rotor_filename), \"w\")\nwrite(f, rotorstring)\nclose(f)\n\nbladestring = \"property,file,description\nchorddist,$cdist_filename, Chord distribution\npitchdist,$pdist_filename, Pitch distribution\nsweepdist,$sdist_filename, LE sweep distribution\nheightdist,$hdist_filename, LE height distribution\nairfoil_files,$airfoils_filename, Airfoil distribution\nspl_k,4,  Spline order\nspl_s,5.0e-7, Spline smoothing\"\n\n# Blade File\nf = open(joinpath(data_path1, blade_filename), \"w\")\nwrite(f, bladestring)\nclose(f)\n\n# Chord Distribution File\nchordstring = \"r/R,c/R\\n\"\nf = open(joinpath(data_path1, cdist_filename), \"w\")\nwrite(f, chordstring)\nfor i=1:length(r)\n    write(f,\"$(chorddist[i,1]),$(chorddist[i,2])\\n\")\nend\nclose(f)\n\n# Height Distribution File\nheightstring = \"r/R,z/R  (height of leading edge from top face of hub)\\n\"\nf = open(joinpath(data_path1, hdist_filename), \"w\")\nwrite(f, heightstring)\nfor i=1:length(r)\n    write(f,\"$(heightdist[i,1]),$(heightdist[i,2])\\n\")\nend\nclose(f)\n\n# Pitch Distribution File\npitchstring = \"r/R,twist (deg)\\n\"\nf = open(joinpath(data_path1, pdist_filename), \"w\")\nwrite(f, pitchstring)\nfor i=1:length(r)\n    write(f,\"$(pitchdist[i,1]),$(pitchdist[i,2])\\n\")\nend\nclose(f)\n\n#Sweep (Leading Edge) Distribution File\nsweepstring = \"r/R,twist (deg)\\n\"\nf = open(joinpath(data_path1, sdist_filename), \"w\")\nwrite(f, sweepstring)\nfor i=1:length(r)\n    write(f,\"$(sweepdist[i,1]),$(sweepdist[i,2])\\n\")\nend\nclose(f)\n\n# Airfoil Section Definition File\nairfoilstring = \"r/R,Contour file,Aero file\n0.0,naca0012.csv,naca0012polarabrev.csv\n1.0,naca0012.csv,naca0012polarabrev.csv\"\nf = open(joinpath(data_path1, airfoils_filename), \"w\")\nwrite(f, airfoilstring)\nclose(f)","category":"page"},{"location":"theory/VPMtheory/#Vortex-Particle-Method-1","page":"Vortex Particle Method","title":"Vortex Particle Method","text":"","category":"section"},{"location":"how-to-guide/select-a-solver/#Select-a-Solver-1","page":"Select a Solver","title":"Select a Solver","text":"","category":"section"},{"location":"theory/FLOWUnsteadytheory/#FLOWUnsteady-1","page":"FLOWUnsteady","title":"FLOWUnsteady","text":"","category":"section"},{"location":"theory/FLOWUnsteadytheory/#","page":"FLOWUnsteady","title":"FLOWUnsteady","text":"Pages = [\"FLOWUnsteady.md\"]","category":"page"},{"location":"#Welcome-to-FLOWUnsteady-1","page":"Home","title":"Welcome to FLOWUnsteady","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you are brand-new to FLOWUnsteady, you should begin with our Getting Started guide in the Tutorials.  You may then consider taking a glance at how to Visualize with Paraview in order to be prepared to visualize as you go.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After getting the code set up, you'll be able to take your First Steps with FLOWUnsteady.","category":"page"}]
}
